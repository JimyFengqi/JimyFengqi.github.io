---
title: Python实现十大常用排序算法
date: 2021-11-01 16:15:10
abbrlink: 4
---

# 排序算法基本内容
常用的十大排序算法中最简单的五种（冒泡、选择、插入、希尔、归并）

可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，

而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。

常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。

主要从：过程图解、算法思想、代码实现、算法分析这四个方面讲解
![排序方法分析](/markdownImages/sort_method_description.jpg)

## 关于时间复杂度
- 1.平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。
- 2.线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序。
- 3.O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。希尔排序。
- 4.线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。

## 关于稳定性

- 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。

- 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。

## 名词解释

    n：数据规模
    k：“桶”的个数
    In-place：占用常数内存，不占用额外内存
    Out-place：占用额外内存

稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同
# 排序算法分析与实现
## 1、冒泡排序
冒泡排序是最简单也是最容易理解的排序方法，其原理就是重复地走访过要排序的数列，

一次比较两个元素，如果他们的顺序错误就把他们交换过来。

走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），
>
>就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名`冒泡排序`。
### 1.过程图解
![冒泡排序图形展示](/markdownImages/bubblesort.gif)
### 2.算法思想

- 从第一个和第二个开始比较，如果第一个比第二个大，则交换位置，然后比较第二个和第三个，逐渐往后
- 经过第一轮后最大的元素已经排在最后，所以重复上述操作的话第二大的则会排在倒数第二的位置。
- 那重复上述操作n-1次即可完成排序，因为最后一次只有一个元素所以不需要比较

### 3.代码实现

```python
# 冒泡排序
def bubbleSort(arr):
    """冒泡排序"""
    # 第一层for表示循环的遍数
    for i in range(len(arr) - 1):
        # 第二层for表示具体比较哪两个元素
        for j in range(len(arr) - 1 - i):
            if arr[j] > arr[j + 1]:
                # 如果前面的大于后面的，则交换这两个元素的位置
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
if __name__ == '__main__':
    li = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]
    print(bubbleSort(li))
```

### 4.算法分析

冒泡排序是一种简单直接暴力的排序算法。

为什么说它暴力？因为每一轮比较可能多个元素移动位置，而元素位置的互换是需要消耗资源的，

所以这是一种偏慢的排序算法，仅适用于对于含有`较少元素`的数列进行排序。

- 稳定性：我们从代码中可以看出只有前一个元素大于后一个元素才可能交换位置，所以相同元素的相对顺序不可能改变，所以它是`稳定排序`
- 比较性：因为排序时元素之间需要比较，所以是`比较排序`
- 时间复杂度：因为它需要双层循环n*(n-1))，所以平均时间复杂度为O(n^2)
- 空间复杂度：只需要常数个辅助单元，所以空间复杂度为O(1)，我们把空间复杂度为O(1)的排序成为`原地排序（in-place）`
- 记忆方法：想象成气泡，一层一层的往上变大

## 2、选择排序

选择排序（Selection sort）是一种简单直观的排序算法。

无论什么数据进去都是 O(n²) 的时间复杂度。

所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，

存放在序列的起始位置，所以称为：`选择排序`

### 1.过程图解
![选择排序图形展示](/markdownImages/selectsort.gif)

### 2.算法思想
- 设第一个元素为比较元素，依次和后面的元素比较，比较完所有元素找到最小（大）的元素，将它和第一个元素互换
- 重复上述操作，我们找出第二小（大）的元素和第二个位置的元素互换，以此类推找出剩余最小元素将它换到前面，即完成排序

### 3.代码实现
```python
def selection_sort(arr):
    """选择排序"""
    # 第一层for表示循环选择的遍数
    for i in range(len(arr) - 1):
        # 将起始元素设为最小元素
        min_index = i
        # 第二层for表示最小元素和后面的元素逐个比较
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_index]:
                # 如果当前元素比最小元素小，则把当前元素角标记为最小元素角标
                min_index = j
        # 查找一遍后将最小元素与起始元素互换
        arr[min_index], arr[i] = arr[i], arr[min_index]
    return arr
if __name__ == '__main__':
    li = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]
    selection_sort(li)
    print(li)
```
另外一种写法,它和冒泡法类似
```python
# 选择排序
def selectSort(li):
    for i in range(len(li)):
        for j in range(i,len(li)):
            if li[i] > li[j]:
                li[i],li[j] = li[j],li[i]

if __name__ == '__main__':
    li = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]
    selectSort(li)
    print(li)

```
### 4.算法分析

`选择排序`和`冒泡排序`很类似，但是选择排序每轮比较只会有一次交换，

而冒泡排序会有多次交换，交换次数比冒泡排序少，就减少cpu的消耗，

所以在数据量小的时候可以用选择排序，实际适用的场合非常少。

- 比较性：因为排序时元素之间需要比较，所以是`比较排序`
- 稳定性：因为存在任意位置的两个元素交换，比如[5, 8, 5, 2]，
  第一个5会和2交换位置，所以改变了两个5原来的相对顺序，所以为`不稳定排序`。
- 时间复杂度：我们看到选择排序同样是双层循环n*(n-1))，所以时间复杂度也为：O(n^2)
- 空间复杂度：只需要常数个辅助单元，所以空间复杂度也为O(1)
- 记忆方法：选择对象要先选最小的

### 3、插入排序

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。

它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要联想到打扑克时的排序就好了
### 1.过程图解
![插入排序图形展示](/markdownImages/insertsort.gif)

### 2.算法思想
- 1.从第二个元素开始和前面的元素进行比较，如果前面的元素比当前元素大，
 
  则将前面元素 后移，当前元素依次往前，直到找到比它小或等于它的元素插入在其后面然后
- 2.选择第三个元素，重复上述操作，进行插入
- 3.依次选择到最后一个元素，插入后即完成所有排序
    
### 3.代码实现
```python
def insertion_sort(arr):
    """插入排序"""
    # 第一层for表示循环插入的遍数
    for i in range(1, len(arr)):
        for j in range(i, 0, -1):  ## 倒序取从下标i的元素开始到下标0
                if arr[j] < arr[j - 1]:
                    arr[j], arr[j - 1] = arr[j - 1], arr[j]
                else: ## 如果当前数值大于前一个数值，退出
                    break
    return arr
```

### 4.算法分析

> 插入排序的适用场景：一个新元素需要插入到一组已经是有序的数组中，或者是一组基本有序的数组排序.

- 1. 比较性：排序时元素之间需要比较，所以为`比较排序`
- 2. 稳定性：从代码我们可以看出只有比较元素大于当前元素，比较元素才会往后移动，所以相同元素是不会改变相对顺序
- 3. 时间复杂度：插入排序同样需要两次循坏一个一个比较，故时间复杂度也为`O(n^2)`
- 4. 空间复杂度：只需要常数个辅助单元，所以空间复杂度也为`O(1)`
- 5. 记忆方法：想象成在书架中插书：先找到相应位置，将后面的书往后推，再将书插入

## 4、希尔排序

希尔排序(Shell's Sort)是插入排序的一种又称“缩小增量(间隔)排序”（Diminishing Increment Sort），

是`插入排序`算法的一种更高效的改进版本，基于·插入排序·的以下两点性质而提出改进方法的：
- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

它与插入排序的不同之处在于，它会优先比较距离较远的元素，该方法因D.L.Shell于1959年提出而得名。

希尔排序的基本思想是：

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，

待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

### 1.过程图解
![希尔排序图形展示](/markdownImages/shellsort.jpg)

### 2.算法思想
希尔排序的整体思想是将固定间隔的几个元素之间排序，然后再缩小这个间隔。这样到最后数列就成为了`基本有序数列`，

而前面我们讲过`插入排序`对基本有序数列排序效果较好。
 
- 1. 计算一个增量（间隔）值 
- 2. 对元素进行增量元素进行比较，比如增量值为7，那么就对0,7,14,21...个元素进行插入排序
- 3. 然后对1,8,15...进行排序，依次递增进行排序 
- 4. 所有元素排序完后，缩小增量比如为3，然后又重复上述第2，3步 
- 5. 最后缩小增量至1时，数列已经基本有序，最后一遍普通插入即可

已知的最增量式是由 `Sedgewick` 提出的 (1, 5, 19, 41, 109,...)，

该步长的项来自 9 * 4^i - 9 * 2^i + 1 和 4^i - 3 * 2^i + 1 这两个算式。

这项研究也表明 `比较` 在希尔排序中是最主要的操作，而不是交换。
 
用这样增量式的`希尔排序`比`插入排序`和`堆排序`都要快，甚至在小数组中比`快速排序`还快，

但是在涉及大量数据时`希尔排序`还是比`快速排序`慢。

### 3.代码实现
```python
def shell_sort(arr):
    """希尔排序"""
    # 取整计算增量（间隔）值
    gap = len(arr) // 2
    while gap > 0:
        # 从增量值开始遍历比较
        for i in range(gap, len(arr)):
            j = i
            current = arr[i]
            # 元素与他同列的前面的每个元素比较，如果比前面的小则互换
            while j - gap >= 0 and current < arr[j - gap]:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = current
        # 缩小增量（间隔）值
        gap //= 2
    return arr
``` 
### 4.算法分析
- 1.比较性：排序时元素之间需要比较，所以为`比较排序`
- 2.稳定性：因为希尔排序是间隔的插入，所以存在相同元素相对顺序被打乱，所以是`不稳定排序`
- 3.时间复杂度： 最坏时间复杂度O(n^2)平均复杂度为`O(n^1.3)`
- 4.空间复杂度：只需要常数个辅助单元，所以空间复杂度也为`O(1)`
- 5.记忆方法：插入排序是每轮都是一小步，希尔排序是先大步后小步，它第一个突破O(n2)的排序算法。

  联想起阿姆斯特朗登月之后说：这是我个人一小步，却是人类迈出的一大步。

## 5、归并排序

归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,

该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

>归并排序适用于子序列有序的数据排序。

### 1.过程图解
![归并排序动画展示](/markdownImages/mergesort.gif)


### 2.算法思想
![归并排序图形展示](/markdownImages/mergesort.jpg)
从上图看分解后的数列很像一个二叉树。

- 使用递归将源数列使用二分法分成多个子列
- 申请空间将两个子列排序合并然后返回
- 将所有子列一步一步合并最后完成排序

### 3.代码实现
```python
def merge_sort(arr):
    """归并排序"""
    if len(arr) == 1:
        return arr
    # 使用二分法将数列分两个
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    # 使用递归运算
    return marge(merge_sort(left), merge_sort(right))


def marge(left, right):
    """排序合并两个数列"""
    result = []
    # 两个数列都有值
    while len(left) > 0 and len(right) > 0:
        # 左右两个数列第一个最小放前面
        if left[0] <= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
    # 只有一个数列中还有值，直接添加
    result += left
    result += right
    return result
```

### 4.算法分析
- 1.比较性：排序时元素之间需要比较，所以为`比较排序`
- 2.稳定性：我们从代码中可以看到当左边的元素小于等于右边的元素就把左边的排前面，

    而原本左边的就是在前面，所以相同元素的相对顺序不变，故为`稳定排序`
- 3.时间复杂度： 复杂度为`O(nlog^n)`
- 4.空间复杂度：在合并子列时需要申请临时空间，而且空间大小随数列的大小而变化，所以空间复杂度为`O(n)`
- 5.记忆方法：所谓归并肯定是要先分解，再合并

## 小结

这五种排序是比较简单的排序，家必须理解&记住它们的算法原理，
因为代码是永远记不住的，只要记住原理你就能用伪代码实现。


## 6、快速排序

快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。

在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。

事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。

快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。

快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。

快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。

虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，

可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：

快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，

比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

### 1.过程图解

![快速排序图形展示](/markdownImages/quicksort.gif)

### 2. 算法思想

- 从数列中挑出一个元素，称为 “基准”（pivot）;
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。
- 在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。

虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

### 3.代码实现
```python
# 快速排序：最快的n*logN
def qiuckSort(list):
    if len(list)<2:
        return list
    pivot = list[0]
    left = [i for i in list[1:] if i <= pivot]
    right = [i for i in list[1:] if i > pivot]
    finallyList = qiuckSort(left)+[pivot] + qiuckSort(right)
    return finallyList

```

### 4.算法分析
- 1.比较性：排序时元素之间需要比较，所以为`比较排序`
- 2.稳定性：我们从代码中可以看到当剩余数列中元素小于等于基准元素的，就把他们放到基准元素前面重新排列，

    剩余数列中元素大于基准元素的，就把他们放到基准元素后面面重新排列，故为`不稳定排序`
- 3.时间复杂度： 复杂度为`O(n*logN)`
- 4.空间复杂度：复杂度为`O(n)`
- 5.记忆方法：比我大的往前站，比我小的往后站，你们自己再按照我的规矩重新排一下， 有点像军训排队