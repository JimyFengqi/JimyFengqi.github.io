---
title: 460-LFU ç¼“å­˜(LFU Cache)
categories:
  - å›°éš¾
tags:
  - è®¾è®¡
  - å“ˆå¸Œè¡¨
  - é“¾è¡¨
  - åŒå‘é“¾è¡¨
abbrlink: 1864832701
date: 2021-12-03 22:45:08
---

> åŸæ–‡é“¾æ¥: https://leetcode-cn.com/problems/lfu-cache


## è‹±æ–‡åŸæ–‡
<div><p>Design and implement a data structure for a <a href="https://en.wikipedia.org/wiki/Least_frequently_used" target="_blank">Least Frequently Used (LFU)</a> cache.</p>

<p>Implement the <code>LFUCache</code> class:</p>

<ul>
	<li><code>LFUCache(int capacity)</code> Initializes the object with the <code>capacity</code> of the data structure.</li>
	<li><code>int get(int key)</code> Gets the value of the <code>key</code> if the <code>key</code> exists in the cache. Otherwise, returns <code>-1</code>.</li>
	<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if present, or inserts the <code>key</code> if not already present. When the cache reaches its <code>capacity</code>, it should invalidate and remove the <strong>least frequently used</strong> key before inserting a new item. For this problem, when there is a <strong>tie</strong> (i.e., two or more keys with the same frequency), the <strong>least recently used</strong> <code>key</code> would be invalidated.</li>
</ul>

<p>To determine the least frequently used key, a <strong>use counter</strong> is maintained for each key in the cache. The key with the smallest <strong>use counter</strong> is the least frequently used key.</p>

<p>When a key is first inserted into the cache, its <strong>use counter</strong> is set to <code>1</code> (due to the <code>put</code> operation). The <strong>use counter</strong> for a key in the cache is incremented either a <code>get</code> or <code>put</code> operation is called on it.</p>

<p>The functions&nbsp;<code data-stringify-type="code">get</code>&nbsp;and&nbsp;<code data-stringify-type="code">put</code>&nbsp;must each run in <code>O(1)</code> average time complexity.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
<strong>Output</strong>
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]

<strong>Explanation</strong>
// cnt(x) = the use counter for key x
// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // return 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.
&nbsp;                // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.
                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // return 4
                 // cache=[3,4], cnt(4)=2, cnt(3)=3
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= capacity&nbsp;&lt;= 10<sup>4</sup></code></li>
	<li><code>0 &lt;= key &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= value &lt;= 10<sup>9</sup></code></li>
	<li>At most <code>2 * 10<sup>5</sup></code>&nbsp;calls will be made to <code>get</code> and <code>put</code>.</li>
</ul>

<p>&nbsp;</p>
<span style="display: none;">&nbsp;</span></div>

## ä¸­æ–‡é¢˜ç›®
<div><p>è¯·ä½ ä¸º <a href="https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95">æœ€ä¸ç»å¸¸ä½¿ç”¨ï¼ˆLFUï¼‰</a>ç¼“å­˜ç®—æ³•è®¾è®¡å¹¶å®ç°æ•°æ®ç»“æ„ã€‚</p>

<p>å®ç° <code>LFUCache</code> ç±»ï¼š</p>

<ul>
	<li><code>LFUCache(int capacity)</code> - ç”¨æ•°æ®ç»“æ„çš„å®¹é‡Â <code>capacity</code> åˆå§‹åŒ–å¯¹è±¡</li>
	<li><code>int get(int key)</code>Â - å¦‚æœé”®å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è·å–é”®çš„å€¼ï¼Œå¦åˆ™è¿”å› -1ã€‚</li>
	<li><code>void put(int key, int value)</code>Â - å¦‚æœé”®å·²å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶å€¼ï¼›å¦‚æœé”®ä¸å­˜åœ¨ï¼Œè¯·æ’å…¥é”®å€¼å¯¹ã€‚å½“ç¼“å­˜è¾¾åˆ°å…¶å®¹é‡æ—¶ï¼Œåˆ™åº”è¯¥åœ¨æ’å…¥æ–°é¡¹ä¹‹å‰ï¼Œä½¿æœ€ä¸ç»å¸¸ä½¿ç”¨çš„é¡¹æ— æ•ˆã€‚åœ¨æ­¤é—®é¢˜ä¸­ï¼Œå½“å­˜åœ¨å¹³å±€ï¼ˆå³ä¸¤ä¸ªæˆ–æ›´å¤šä¸ªé”®å…·æœ‰ç›¸åŒä½¿ç”¨é¢‘ç‡ï¼‰æ—¶ï¼Œåº”è¯¥å»é™¤ <strong>æœ€è¿‘æœ€ä¹…æœªä½¿ç”¨</strong> çš„é”®ã€‚</li>
</ul>

<p><strong>æ³¨æ„</strong>ã€Œé¡¹çš„ä½¿ç”¨æ¬¡æ•°ã€å°±æ˜¯è‡ªæ’å…¥è¯¥é¡¹ä»¥æ¥å¯¹å…¶è°ƒç”¨ <code>get</code> å’Œ <code>put</code> å‡½æ•°çš„æ¬¡æ•°ä¹‹å’Œã€‚ä½¿ç”¨æ¬¡æ•°ä¼šåœ¨å¯¹åº”é¡¹è¢«ç§»é™¤åç½®ä¸º 0 ã€‚</p>

<p>ä¸ºäº†ç¡®å®šæœ€ä¸å¸¸ä½¿ç”¨çš„é”®ï¼Œå¯ä»¥ä¸ºç¼“å­˜ä¸­çš„æ¯ä¸ªé”®ç»´æŠ¤ä¸€ä¸ª <strong>ä½¿ç”¨è®¡æ•°å™¨</strong> ã€‚ä½¿ç”¨è®¡æ•°æœ€å°çš„é”®æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„é”®ã€‚</p>

<p>å½“ä¸€ä¸ªé”®é¦–æ¬¡æ’å…¥åˆ°ç¼“å­˜ä¸­æ—¶ï¼Œå®ƒçš„ä½¿ç”¨è®¡æ•°å™¨è¢«è®¾ç½®ä¸º <code>1</code> (ç”±äº put æ“ä½œ)ã€‚å¯¹ç¼“å­˜ä¸­çš„é”®æ‰§è¡Œ <code>get</code> æˆ– <code>put</code> æ“ä½œï¼Œä½¿ç”¨è®¡æ•°å™¨çš„å€¼å°†ä¼šé€’å¢ã€‚</p>

<p>Â </p>

<p><strong>ç¤ºä¾‹ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>
["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
<strong>è¾“å‡ºï¼š</strong>
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]

<strong>è§£é‡Šï¼š</strong>
// cnt(x) = é”® x çš„ä½¿ç”¨è®¡æ•°
// cache=[] å°†æ˜¾ç¤ºæœ€åä¸€æ¬¡ä½¿ç”¨çš„é¡ºåºï¼ˆæœ€å·¦è¾¹çš„å…ƒç´ æ˜¯æœ€è¿‘çš„ï¼‰
LFUCache lFUCache = new LFUCache(2);
lFUCache.put(1, 1);   // cache=[1,_], cnt(1)=1
lFUCache.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lFUCache.get(1);      // è¿”å› 1
                      // cache=[1,2], cnt(2)=1, cnt(1)=2
lFUCache.put(3, 3);   // å»é™¤é”® 2 ï¼Œå› ä¸º cnt(2)=1 ï¼Œä½¿ç”¨è®¡æ•°æœ€å°
                      // cache=[3,1], cnt(3)=1, cnt(1)=2
lFUCache.get(2);      // è¿”å› -1ï¼ˆæœªæ‰¾åˆ°ï¼‰
lFUCache.get(3);      // è¿”å› 3
                      // cache=[3,1], cnt(3)=2, cnt(1)=2
lFUCache.put(4, 4);   // å»é™¤é”® 1 ï¼Œ1 å’Œ 3 çš„ cnt ç›¸åŒï¼Œä½† 1 æœ€ä¹…æœªä½¿ç”¨
                      // cache=[4,3], cnt(4)=1, cnt(3)=2
lFUCache.get(1);      // è¿”å› -1ï¼ˆæœªæ‰¾åˆ°ï¼‰
lFUCache.get(3);      // è¿”å› 3
                      // cache=[3,4], cnt(4)=1, cnt(3)=3
lFUCache.get(4);      // è¿”å› 4
                      // cache=[3,4], cnt(4)=2, cnt(3)=3</pre>

<p>Â </p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
	<li><code>0 <=Â capacity, key, value <= 10<sup>4</sup></code></li>
	<li>æœ€å¤šè°ƒç”¨ <code>10<sup>5</sup></code> æ¬¡ <code>get</code> å’Œ <code>put</code> æ–¹æ³•</li>
</ul>

<p>Â </p>

<p><strong>è¿›é˜¶ï¼š</strong>ä½ å¯ä»¥ä¸ºè¿™ä¸¤ç§æ“ä½œè®¾è®¡æ—¶é—´å¤æ‚åº¦ä¸º <code>O(1)</code> çš„å®ç°å—ï¼Ÿ</p>
</div>

## é€šè¿‡ä»£ç 
<RecoDemo>
</RecoDemo>


## é«˜èµé¢˜è§£
ğŸ™‹**æˆ‘ä»¥å‰çš„é¢˜è§£ç«Ÿç„¶è¢«æ¯æ—¥ä¸€é¢˜ç¿»ç‰Œäº†ï¼Œä»Šå¤©ç»ˆäºä¸ç”¨æ–°æ›´äº†å‘¢**

**ä»¥ä¸‹è§£æ³•ä¸­ï¼Œæ–¹æ³• 3 ç›¸å¯¹äºå…¶ä»–äººå¾ˆå¤šå‡ ç™¾æ¯«ç§’çš„ $O(1)$ å®ç°æ¥è¯´ï¼Œæ˜¯ç›®å‰æœ€ä¼˜çš„ $O(1)$ å®ç°å“¦ï¼Œåªéœ€è¦ 13 æ¯«ç§’ï¼~**
**æƒ³çœ‹æ›´å¤šå¹²è´§é¢˜è§£ï¼Œè¯·æˆ³ [æˆ‘çš„ä¸»é¡µ](https://leetcode-cn.com/u/sweetiee/)ï¼**

----


 [TOC]

### ä¸€ã€$O(1)$ è§£æ³•

ä¸‹é¢è¦è¯´çš„ $O(1)$ çš„ 3 ç§ Java å†™æ³•å…¶å®æ˜¯ 1 ç§è§£æ³•ï¼Œå› ä¸ºå…·ä½“å®ç°ç»†èŠ‚ä¸­ä½¿ç”¨çš„æ•°æ®ç»“æ„ä¸åŒï¼Œå¯¼è‡´æ€§èƒ½æœ‰æ‰€å·®å¼‚ã€‚ä¸ºæ–¹ä¾¿ç†è§£ï¼Œä¸‹é¢ 3 ä¸ªå®ç°ï¼Œ**æ€§èƒ½ä»ç•¥æŒ«é€æ­¥ä¼˜åŒ–**ï¼š

1. `HashMap<Integer, Node> cache` å­˜ç¼“å­˜çš„å†…å®¹; `min` æ˜¯æœ€å°è®¿é—®é¢‘æ¬¡; `HashMap<Integer, LinkedHashSet<Node>> freqMap` å­˜æ¯ä¸ªè®¿é—®é¢‘æ¬¡å¯¹åº”çš„ Node çš„åŒå‘é“¾è¡¨ï¼ˆå†™æ³• 1 ä¸ºäº†æ–¹ä¾¿ï¼Œç›´æ¥ç”¨äº† JDK ç°æœ‰çš„ LinkedHashSetï¼Œå…¶å®ç°äº† 1 æ¡åŒå‘é“¾è¡¨è´¯ç©¿å“ˆå¸Œè¡¨ä¸­çš„æ‰€æœ‰ Entryï¼Œæ”¯æŒä»¥æ’å…¥çš„å…ˆåé¡ºåºå¯¹åŸæœ¬æ— åºçš„ HashSet è¿›è¡Œè¿­ä»£ï¼‰

2. `HashMap<Integer, Node> cache` å­˜ç¼“å­˜çš„å†…å®¹; `min` æ˜¯æœ€å°è®¿é—®é¢‘æ¬¡; `HashMap<Integer, DoublyLinkedList>freqMap` å­˜æ¯ä¸ªè®¿é—®é¢‘æ¬¡å¯¹åº”çš„ Node çš„åŒå‘é“¾è¡¨ï¼ˆå†™æ³• 2 ä¸å†™æ³• 1 ä¸€æ ·ï¼Œåªä¸è¿‡å°† JDK è‡ªå¸¦çš„ LinkedHashSet åŒå‘é“¾è¡¨å®ç°æ”¹æˆäº†è‡ªå®šä¹‰çš„åŒå‘é“¾è¡¨ DoublyLinkedListï¼Œå‡å°‘äº†ä¸€äº›å“ˆå¸Œç›¸å…³çš„è€—æ—¶ï¼‰

3. `HashMap<Integer, Node> cache` å­˜ç¼“å­˜çš„å†…å®¹; å°†å†™æ³• 1 å†™æ³• 2 ä¸­çš„ freqMap ä¸å†ç”¨ HashMap æ¥è¡¨ç¤ºï¼Œè€Œæ˜¯ç›´æ¥ç”¨åŒå‘é“¾è¡¨ `DoublyLinkedList firstLinkedList; DoublyLinkedList lastLinkedList`ï¼Œçœå»äº†ä¸€äº›å“ˆå¸Œç›¸å…³çš„è€—æ—¶ï¼Œä¹Ÿä¸éœ€è¦ç”¨ min æ¥å­˜å‚¨æœ€å°é¢‘æ¬¡äº†ï¼ŒlastLinkedList.pre è¿™æ¡ DoublyLinkedList å³ä¸ºæœ€å°é¢‘æ¬¡å¯¹åº”çš„ Node åŒå‘é“¾è¡¨ï¼ŒlastLinkedList.pre.tail.pre è¿™ä¸ª Node å³ä¸ºæœ€å°é¢‘æ¬¡çš„åŒå‘é“¾è¡¨ä¸­çš„æ‰€æœ‰ Node ä¸­æœ€å…ˆè®¿é—®çš„ Nodeï¼Œå³å®¹é‡æ»¡äº†åè¦åˆ é™¤çš„ Nodeã€‚


**ä¸‹é¢è´´è¿™ä»¨å®ç°ï¼Œä¸å¤šå“”å“”äº†ç›´æ¥åœ¨ä»£ç ä¸­æ³¨é‡Šå•¦**
**æœ€ä¼˜è§£æ˜¯ç¬¬ä¸‰ç§ï¼Œè¯¦å°½æ³¨é‡Šäº†ã€‚ å…¶ä»–çš„å®ç°å®åœ¨æ‡’å¾—æ³¨é‡Šäº†å“ğŸ¥ºï¼Œæ²¡æ³•æŠ˜å å¥½å‚»xï¼Œç›´æ¥è·³å»ç¬¬ä¸‰ç§å­**


#### O(1) è§£æ³• â€”â€” åŒå‘é“¾è¡¨ç›´æ¥ä½¿ç”¨LinkedHashSet
``` Java
class LFUCache {
    Map<Integer, Node> cache;  // å­˜å‚¨ç¼“å­˜çš„å†…å®¹
    Map<Integer, LinkedHashSet<Node>> freqMap; // å­˜å‚¨æ¯ä¸ªé¢‘æ¬¡å¯¹åº”çš„åŒå‘é“¾è¡¨
    int size;
    int capacity;
    int min; // å­˜å‚¨å½“å‰æœ€å°é¢‘æ¬¡

    public LFUCache(int capacity) {
        cache = new HashMap<> (capacity);
        freqMap = new HashMap<>();
        this.capacity = capacity;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        freqInc(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        Node node = cache.get(key);
        if (node != null) {
            node.value = value;
            freqInc(node);
        } else {
            if (size == capacity) {
                Node deadNode = removeNode();
                cache.remove(deadNode.key);
                size--;
            }
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            addNode(newNode);
            size++;     
        }
    }

    void freqInc(Node node) {
        // ä»åŸfreqå¯¹åº”çš„é“¾è¡¨é‡Œç§»é™¤, å¹¶æ›´æ–°min
        int freq = node.freq;
        LinkedHashSet<Node> set = freqMap.get(freq);
        set.remove(node);
        if (freq == min && set.size() == 0) { 
            min = freq + 1;
        }
        // åŠ å…¥æ–°freqå¯¹åº”çš„é“¾è¡¨
        node.freq++;
        LinkedHashSet<Node> newSet = freqMap.get(freq + 1);
        if (newSet == null) {
            newSet = new LinkedHashSet<>();
            freqMap.put(freq + 1, newSet);
        }
        newSet.add(node);
    }

    void addNode(Node node) {
        LinkedHashSet<Node> set = freqMap.get(1);
        if (set == null) {
            set = new LinkedHashSet<>();
            freqMap.put(1, set);
        } 
        set.add(node); 
        min = 1;
    }

    Node removeNode() {
        LinkedHashSet<Node> set = freqMap.get(min);
        Node deadNode = set.iterator().next();
        set.remove(deadNode);
        return deadNode;
    }
}

class Node {
    int key;
    int value;
    int freq = 1;

    public Node() {}
    
    public Node(int key, int value) {
        this.key = key;
        this.value = value;
    }
}
```

#### O(1) è§£æ³• â€”â€” è‡ªå®šä¹‰åŒå‘é“¾è¡¨
``` Java
class LFUCache {
    Map<Integer, Node> cache; // å­˜å‚¨ç¼“å­˜çš„å†…å®¹
    Map<Integer, DoublyLinkedList> freqMap; // å­˜å‚¨æ¯ä¸ªé¢‘æ¬¡å¯¹åº”çš„åŒå‘é“¾è¡¨
    int size;
    int capacity;
    int min; // å­˜å‚¨å½“å‰æœ€å°é¢‘æ¬¡

    public LFUCache(int capacity) {
        cache = new HashMap<> (capacity);
        freqMap = new HashMap<>();
        this.capacity = capacity;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        freqInc(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        Node node = cache.get(key);
        if (node != null) {
            node.value = value;
            freqInc(node);
        } else {
            if (size == capacity) {
                DoublyLinkedList minFreqLinkedList = freqMap.get(min);
                cache.remove(minFreqLinkedList.tail.pre.key);
                minFreqLinkedList.removeNode(minFreqLinkedList.tail.pre); // è¿™é‡Œä¸éœ€è¦ç»´æŠ¤min, å› ä¸ºä¸‹é¢addäº†newNodeåminè‚¯å®šæ˜¯1.
                size--;
            }
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            DoublyLinkedList linkedList = freqMap.get(1);
            if (linkedList == null) {
                linkedList = new DoublyLinkedList();
                freqMap.put(1, linkedList);
            }
            linkedList.addNode(newNode);
            size++;  
            min = 1;   
        }
    }

    void freqInc(Node node) {
        // ä»åŸfreqå¯¹åº”çš„é“¾è¡¨é‡Œç§»é™¤, å¹¶æ›´æ–°min
        int freq = node.freq;
        DoublyLinkedList linkedList = freqMap.get(freq);
        linkedList.removeNode(node);
        if (freq == min && linkedList.head.post == linkedList.tail) { 
            min = freq + 1;
        }
        // åŠ å…¥æ–°freqå¯¹åº”çš„é“¾è¡¨
        node.freq++;
        linkedList = freqMap.get(freq + 1);
        if (linkedList == null) {
            linkedList = new DoublyLinkedList();
            freqMap.put(freq + 1, linkedList);
        }
        linkedList.addNode(node);
    }
}

class Node {
    int key;
    int value;
    int freq = 1;
    Node pre;
    Node post;

    public Node() {}
    
    public Node(int key, int value) {
        this.key = key;
        this.value = value;
    }
}

class DoublyLinkedList {
    Node head;
    Node tail;

    public DoublyLinkedList() {
        head = new Node();
        tail = new Node();
        head.post = tail;
        tail.pre = head;
    }

    void removeNode(Node node) {
        node.pre.post = node.post;
        node.post.pre = node.pre;
    }

    void addNode(Node node) {
        node.post = head.post;
        head.post.pre = node;
        head.post = node;
        node.pre = head;
    }
}
```

#### O(1) è§£æ³• â€”â€” å­˜å‚¨é¢‘æ¬¡çš„HashMapæ”¹ä¸ºç›´æ¥ç”¨åŒå‘é“¾è¡¨ï¼ˆæœ€ä¼˜å®ç° 13ms åŒ100%ï¼‰

``` Java

class LFUCache {

  Map<Integer, Node> cache;  // å­˜å‚¨ç¼“å­˜çš„å†…å®¹ï¼ŒNodeä¸­é™¤äº†valueå€¼å¤–ï¼Œè¿˜æœ‰keyã€freqã€æ‰€åœ¨doublyLinkedListã€æ‰€åœ¨doublyLinkedListä¸­çš„postNodeã€æ‰€åœ¨doublyLinkedListä¸­çš„preNodeï¼Œå…·ä½“å®šä¹‰åœ¨ä¸‹æ–¹ã€‚

  DoublyLinkedList firstLinkedList; // firstLinkedList.post æ˜¯é¢‘æ¬¡æœ€å¤§çš„åŒå‘é“¾è¡¨

  DoublyLinkedList lastLinkedList;  // lastLinkedList.pre æ˜¯é¢‘æ¬¡æœ€å°çš„åŒå‘é“¾è¡¨ï¼Œæ»¡äº†ä¹‹ååˆ é™¤ lastLinkedList.pre.tail.pre è¿™ä¸ªNodeå³ä¸ºé¢‘æ¬¡æœ€å°ä¸”è®¿é—®æœ€æ—©çš„Node

  int size;

  int capacity;



  public LFUCache(int capacity) {

â€‹    cache = new HashMap<> (capacity);

â€‹    firstLinkedList = new DoublyLinkedList();

â€‹    lastLinkedList = new DoublyLinkedList();

â€‹    firstLinkedList.post = lastLinkedList;

â€‹    lastLinkedList.pre = firstLinkedList;

â€‹    this.capacity = capacity;

  }

  

  public int get(int key) {

â€‹    Node node = cache.get(key);

â€‹    if (node == null) {

â€‹      return -1;

â€‹    }

    // è¯¥keyè®¿é—®é¢‘æ¬¡+1

â€‹    freqInc(node);

â€‹    return node.value;

  }

  

  public void put(int key, int value) {

â€‹    if (capacity == 0) {

â€‹      return;

â€‹    }

â€‹    Node node = cache.get(key);

    // è‹¥keyå­˜åœ¨ï¼Œåˆ™æ›´æ–°valueï¼Œè®¿é—®é¢‘æ¬¡+1

â€‹    if (node != null) {

â€‹      node.value = value;

â€‹      freqInc(node);

â€‹    } else {

      // è‹¥keyä¸å­˜åœ¨

â€‹      if (size == capacity) {

â€‹        // å¦‚æœç¼“å­˜æ»¡äº†ï¼Œåˆ é™¤lastLinkedList.preè¿™ä¸ªé“¾è¡¨ï¼ˆå³è¡¨ç¤ºæœ€å°é¢‘æ¬¡çš„é“¾è¡¨ï¼‰ä¸­çš„tail.preè¿™ä¸ªNodeï¼ˆå³æœ€å°é¢‘æ¬¡é“¾è¡¨ä¸­æœ€å…ˆè®¿é—®çš„Nodeï¼‰ï¼Œå¦‚æœè¯¥é“¾è¡¨ä¸­çš„å…ƒç´ åˆ ç©ºäº†ï¼Œåˆ™åˆ æ‰è¯¥é“¾è¡¨ã€‚

â€‹        cache.remove(lastLinkedList.pre.tail.pre.key);

â€‹        lastLinkedList.removeNode(lastLinkedList.pre.tail.pre);

â€‹        size--;

â€‹        if (lastLinkedList.pre.head.post == lastLinkedList.pre.tail) {

â€‹          removeDoublyLinkedList(lastLinkedList.pre);

â€‹        } 

â€‹      }

      // cacheä¸­putæ–°Key-Nodeå¯¹å„¿ï¼Œå¹¶å°†æ–°nodeåŠ å…¥è¡¨ç¤ºfreqä¸º1çš„DoublyLinkedListä¸­ï¼Œè‹¥ä¸å­˜åœ¨freqä¸º1çš„DoublyLinkedListåˆ™æ–°å»ºã€‚

â€‹      Node newNode = new Node(key, value);

â€‹      cache.put(key, newNode);

â€‹      if (lastLinkedList.pre.freq != 1) {

â€‹        DoublyLinkedList newDoublyLinedList = new DoublyLinkedList(1);

â€‹        addDoublyLinkedList(newDoublyLinedList, lastLinkedList.pre);

â€‹        newDoublyLinedList.addNode(newNode);

â€‹      } else {

â€‹        lastLinkedList.pre.addNode(newNode);

â€‹      }

â€‹      size++;

â€‹    }

  }


  /**
   * nodeçš„è®¿é—®é¢‘æ¬¡ + 1
   */
  void freqInc(Node node) {

â€‹    // å°†nodeä»åŸfreqå¯¹åº”çš„åŒå‘é“¾è¡¨é‡Œç§»é™¤, å¦‚æœé“¾è¡¨ç©ºäº†åˆ™åˆ é™¤é“¾è¡¨ã€‚

â€‹    DoublyLinkedList linkedList = node.doublyLinkedList;

â€‹    DoublyLinkedList preLinkedList = linkedList.pre;

â€‹    linkedList.removeNode(node);

â€‹    if (linkedList.head.post == linkedList.tail) { 

â€‹      removeDoublyLinkedList(linkedList);

â€‹    }


â€‹    // å°†nodeåŠ å…¥æ–°freqå¯¹åº”çš„åŒå‘é“¾è¡¨ï¼Œè‹¥è¯¥é“¾è¡¨ä¸å­˜åœ¨ï¼Œåˆ™å…ˆåˆ›å»ºè¯¥é“¾è¡¨ã€‚

â€‹    node.freq++;

â€‹    if (preLinkedList.freq != node.freq) {

â€‹      DoublyLinkedList newDoublyLinedList = new DoublyLinkedList(node.freq);

â€‹      addDoublyLinkedList(newDoublyLinedList, preLinkedList);

â€‹      newDoublyLinedList.addNode(node);

â€‹    } else {

â€‹      preLinkedList.addNode(node);

â€‹    }

  }


  /**
   * å¢åŠ ä»£è¡¨æŸ1é¢‘æ¬¡çš„åŒå‘é“¾è¡¨
   */
  void addDoublyLinkedList(DoublyLinkedList newDoublyLinedList, DoublyLinkedList preLinkedList) {

â€‹    newDoublyLinedList.post = preLinkedList.post;

â€‹    newDoublyLinedList.post.pre = newDoublyLinedList;

â€‹    newDoublyLinedList.pre = preLinkedList;

â€‹    preLinkedList.post = newDoublyLinedList; 

  }


  /**
   * åˆ é™¤ä»£è¡¨æŸ1é¢‘æ¬¡çš„åŒå‘é“¾è¡¨
   */
  void removeDoublyLinkedList(DoublyLinkedList doublyLinkedList) {

â€‹    doublyLinkedList.pre.post = doublyLinkedList.post;

â€‹    doublyLinkedList.post.pre = doublyLinkedList.pre;

  }

}



class Node {

  int key;

  int value;

  int freq = 1;

  Node pre; // Nodeæ‰€åœ¨é¢‘æ¬¡çš„åŒå‘é“¾è¡¨çš„å‰ç»§Node 

  Node post; // Nodeæ‰€åœ¨é¢‘æ¬¡çš„åŒå‘é“¾è¡¨çš„åç»§Node

  DoublyLinkedList doublyLinkedList;  // Nodeæ‰€åœ¨é¢‘æ¬¡çš„åŒå‘é“¾è¡¨



  public Node() {}

  

  public Node(int key, int value) {

â€‹    this.key = key;

â€‹    this.value = value;

  }

}



class DoublyLinkedList {

  int freq; // è¯¥åŒå‘é“¾è¡¨è¡¨ç¤ºçš„é¢‘æ¬¡

  DoublyLinkedList pre;  // è¯¥åŒå‘é“¾è¡¨çš„å‰ç»§é“¾è¡¨ï¼ˆpre.freq < this.freqï¼‰

  DoublyLinkedList post; // è¯¥åŒå‘é“¾è¡¨çš„åç»§é“¾è¡¨ (post.freq > this.freq)

  Node head; // è¯¥åŒå‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œæ–°èŠ‚ç‚¹ä»å¤´éƒ¨åŠ å…¥ï¼Œè¡¨ç¤ºæœ€è¿‘è®¿é—®

  Node tail; // è¯¥åŒå‘é“¾è¡¨çš„å°¾èŠ‚ç‚¹ï¼Œåˆ é™¤èŠ‚ç‚¹ä»å°¾éƒ¨åˆ é™¤ï¼Œè¡¨ç¤ºæœ€ä¹…è®¿é—®



  public DoublyLinkedList() {

â€‹    head = new Node();

â€‹    tail = new Node();

â€‹    head.post = tail;

â€‹    tail.pre = head;

  }



  public DoublyLinkedList(int freq) {

â€‹    head = new Node();

â€‹    tail = new Node();

â€‹    head.post = tail;

â€‹    tail.pre = head;

â€‹    this.freq = freq;

  }



  void removeNode(Node node) {

â€‹    node.pre.post = node.post;

â€‹    node.post.pre = node.pre;

  }



  void addNode(Node node) {

â€‹    node.post = head.post;

â€‹    head.post.pre = node;

â€‹    head.post = node;

â€‹    node.pre = head;

â€‹    node.doublyLinkedList = this;

  }



}

```



---

## äºŒã€$O(logN)$ è§£æ³•

#### O(logN) è§£æ³• â€”â€” ä½¿ç”¨å°æ ¹å †æ‰¾åˆ° `freq` æœ€å°ï¼Œå› ä¸º Java ä¸­çš„ PriorityQueue é»˜è®¤å°±æ˜¯å°æ ¹å †, å®ç°æœ€ç®€å•

æ¯æ¬¡å°†è®¿é—®é¢‘æ¬¡ `freq` æœ€å°çš„ä¸”æœ€å…ˆè®¿é—®çš„ä¸Šæµ®åˆ°å †é¡¶ï¼Œä¸‹é¢ç”¨å…¨å±€è‡ªå¢ `idx` è¡¨ç¤ºè®¿é—®çš„å…ˆåï¼Œæˆ–è€…å¯ä»¥ç›´æ¥æ”¹æˆ `idx = System.nanoTime()` ç”¨ä»¥æ¯”è¾ƒè®¿é—®æ—¶é—´çš„å…ˆåã€‚

``` Java
class LFUCache {

    Map<Integer, Node> cache;
    Queue<Node> queue;
    int capacity;
    int size;
    int idx = 0;

    public LFUCache(int capacity) {
        cache = new HashMap<>(capacity);
        if (capacity > 0) {
            queue = new PriorityQueue<>(capacity);
        }
        this.capacity = capacity;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        node.freq++;
        node.idx = idx++;
        queue.remove(node);
        queue.offer(node);
        return node.value;

    }
    
    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        Node node = cache.get(key);
        if (node != null) {
            node.value = value;
            node.freq++;
            node.idx = idx++;
            queue.remove(node);
            queue.offer(node);
        } else {
            if (size == capacity) {
                cache.remove(queue.peek().key);
                queue.poll();
                size--;
            } 
            Node newNode = new Node(key, value, idx++);
            cache.put(key, newNode);
            queue.offer(newNode);
            size++;
        }
    }
}

class Node implements Comparable<Node> {
    int key;
    int value;
    int freq;
    int idx;

    public Node() {}

    public Node(int key, int value, int idx) {
        this.key = key;
        this.value = value;
        freq = 1;
        this.idx = idx;
    }

    public int compareTo(Node node) {
		int diff = freq - node.freq;
        return diff != 0? diff: idx - node.idx;
    }
}
```

## ä¸‰ã€O(N) è§£æ³•

#### æœ€å‚»fufuã® O(N) â€”â€” åªç”¨1æ¡åŒå‘é“¾è¡¨

ä½¿ `freq` å°çš„ `Node` åœ¨é“¾è¡¨çš„å·¦è¾¹ï¼Œ`freq` å¤§çš„ `Node` åœ¨é“¾è¡¨çš„å³è¾¹ï¼Œ`freq` ç›¸ç­‰çš„è¯æœ€ä¹…ä½¿ç”¨çš„ `Node` åœ¨å·¦è¾¹ã€æœ€è¿‘ä½¿ç”¨çš„ `Node` åœ¨å³è¾¹ï¼Œå› æ­¤æ»¡äº†ä¹‹ååˆ é™¤ `head.post`ï¼Œè¯¥ `Node` å³ `freq` æœ€å°ä¸”æœ€ä¹…è®¿é—®çš„ã€‚
æ¯æ¬¡ `node` çš„ `freq++` åï¼Œä»å½“å‰ä½ç½®å‘åéå†é“¾è¡¨ï¼Œç›´åˆ° `nextNode.freq > node.freq || nextNode == tail`ï¼Œåœ¨ `nextNode` ä¹‹å‰æ’å…¥è¯¥ `node`ã€‚

``` Java
class LFUCache {

    HashMap<Integer, Node> cache;
    Node head;
    Node tail;
    int capacity;
    int size;

    public LFUCache(int capacity) {
        cache = new HashMap<Integer, Node>(capacity);
        this.capacity = capacity;
        head = new Node();
        tail = new Node();
        head.post = tail;
        tail.pre = head;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        node.freq++;
        moveToNewPosition(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        Node node = cache.get(key);
        if (node != null) {
            node.value = value;
            node.freq++;
            moveToNewPosition(node);
        } else {
            if (size == capacity) {
                cache.remove(head.post.key);
                removeNode(head.post);
                size--;
            }
            Node newNode = new Node(key, value);
            addNode(newNode);
            cache.put(key, newNode);
            size++;
        }
    }

    private void moveToNewPosition(Node node) {
        Node nextNode = node.post;
        removeNode(node);
        while (nextNode.freq <= node.freq && nextNode != tail) {
            nextNode = nextNode.post;
        }
        nextNode.pre.post = node;
        node.pre = nextNode.pre;
        node.post = nextNode;
        nextNode.pre = node;
    }

    private void addNode(Node node) {
        node.post = head.post;
        node.pre = head;
        head.post.pre = node;
        head.post = node;
        moveToNewPosition(node);
    }

    private void removeNode(Node node) {
        node.pre.post = node.post;
        node.post.pre = node.pre;
    }
}

class Node {
    int key;
    int value;
    int freq = 1;
    Node pre;
    Node post;

    public Node() {}
    public Node(int key, int value) {
        this.key = key;
        this.value = value;
    }
}
```


---

å—¯ï¼Œå¾ˆå…¨/::)

## ç»Ÿè®¡ä¿¡æ¯
| é€šè¿‡æ¬¡æ•° | æäº¤æ¬¡æ•° | ACæ¯”ç‡ |
| :------: | :------: | :------: |
|    36059    |    82791    |   43.6%   |

## æäº¤å†å²
| æäº¤æ—¶é—´ | æäº¤ç»“æœ | æ‰§è¡Œæ—¶é—´ |  å†…å­˜æ¶ˆè€—  | è¯­è¨€ |
| :------: | :------: | :------: | :--------: | :--------: |


## ç›¸ä¼¼é¢˜ç›®
|                             é¢˜ç›®                             | éš¾åº¦ |
| :----------------------------------------------------------: | :---------: |
| [LRU ç¼“å­˜æœºåˆ¶](https://leetcode-cn.com/problems/lru-cache/) | ä¸­ç­‰|
| [è®¾è®¡å†…å­˜æ–‡ä»¶ç³»ç»Ÿ](https://leetcode-cn.com/problems/design-in-memory-file-system/) | å›°éš¾|
