---
title: 990-ç­‰å¼æ–¹ç¨‹çš„å¯æ»¡è¶³æ€§(Satisfiability of Equality Equations)
date: 2021-12-03 22:27:28
categories:
  - ä¸­ç­‰
tags:
  - å¹¶æŸ¥é›†
  - å›¾
  - æ•°ç»„
  - å­—ç¬¦ä¸²
---

> åŸæ–‡é“¾æ¥: https://leetcode-cn.com/problems/satisfiability-of-equality-equations


## è‹±æ–‡åŸæ–‡
<div><p>You are given an array of strings <code>equations</code> that represent relationships between variables where each string <code>equations[i]</code> is of length <code>4</code> and takes one of two different forms: <code>&quot;x<sub>i</sub>==y<sub>i</sub>&quot;</code> or <code>&quot;x<sub>i</sub>!=y<sub>i</sub>&quot;</code>.Here, <code>x<sub>i</sub></code> and <code>y<sub>i</sub></code> are lowercase letters (not necessarily different) that represent one-letter variable names.</p>

<p>Return <code>true</code><em> if it is possible to assign integers to variable names so as to satisfy all the given equations, or </em><code>false</code><em> otherwise</em>.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre>
<strong>Input:</strong> equations = [&quot;a==b&quot;,&quot;b!=a&quot;]
<strong>Output:</strong> false
<strong>Explanation:</strong> If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.
There is no way to assign the variables to satisfy both equations.
</pre>

<p><strong>Example 2:</strong></p>

<pre>
<strong>Input:</strong> equations = [&quot;b==a&quot;,&quot;a==b&quot;]
<strong>Output:</strong> true
<strong>Explanation:</strong> We could assign a = 1 and b = 1 to satisfy both equations.
</pre>

<p><strong>Example 3:</strong></p>

<pre>
<strong>Input:</strong> equations = [&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]
<strong>Output:</strong> true
</pre>

<p><strong>Example 4:</strong></p>

<pre>
<strong>Input:</strong> equations = [&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]
<strong>Output:</strong> false
</pre>

<p><strong>Example 5:</strong></p>

<pre>
<strong>Input:</strong> equations = [&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]
<strong>Output:</strong> true
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= equations.length &lt;= 500</code></li>
	<li><code>equations[i].length == 4</code></li>
	<li><code>equations[i][0]</code> is a lowercase letter.</li>
	<li><code>equations[i][1]</code> is either <code>&#39;=&#39;</code> or <code>&#39;!&#39;</code>.</li>
	<li><code>equations[i][2]</code> is <code>&#39;=&#39;</code>.</li>
	<li><code>equations[i][3]</code> is a lowercase letter.</li>
</ul>
</div>

## ä¸­æ–‡é¢˜ç›®
<div><p>ç»™å®šä¸€ä¸ªç”±è¡¨ç¤ºå˜é‡ä¹‹é—´å…³ç³»çš„å­—ç¬¦ä¸²æ–¹ç¨‹ç»„æˆçš„æ•°ç»„ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²æ–¹ç¨‹ <code>equations[i]</code> çš„é•¿åº¦ä¸º <code>4</code>ï¼Œå¹¶é‡‡ç”¨ä¸¤ç§ä¸åŒçš„å½¢å¼ä¹‹ä¸€ï¼š<code>&quot;a==b&quot;</code> æˆ–&nbsp;<code>&quot;a!=b&quot;</code>ã€‚åœ¨è¿™é‡Œï¼Œa å’Œ b æ˜¯å°å†™å­—æ¯ï¼ˆä¸ä¸€å®šä¸åŒï¼‰ï¼Œè¡¨ç¤ºå•å­—æ¯å˜é‡åã€‚</p>

<p>åªæœ‰å½“å¯ä»¥å°†æ•´æ•°åˆ†é…ç»™å˜é‡åï¼Œä»¥ä¾¿æ»¡è¶³æ‰€æœ‰ç»™å®šçš„æ–¹ç¨‹æ—¶æ‰è¿”å›&nbsp;<code>true</code>ï¼Œå¦åˆ™è¿”å› <code>false</code>ã€‚&nbsp;</p>

<p>&nbsp;</p>

<ol>
</ol>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<pre><strong>è¾“å…¥ï¼š</strong>[&quot;a==b&quot;,&quot;b!=a&quot;]
<strong>è¾“å‡ºï¼š</strong>false
<strong>è§£é‡Šï¼š</strong>å¦‚æœæˆ‘ä»¬æŒ‡å®šï¼Œa = 1 ä¸” b = 1ï¼Œé‚£ä¹ˆå¯ä»¥æ»¡è¶³ç¬¬ä¸€ä¸ªæ–¹ç¨‹ï¼Œä½†æ— æ³•æ»¡è¶³ç¬¬äºŒä¸ªæ–¹ç¨‹ã€‚æ²¡æœ‰åŠæ³•åˆ†é…å˜é‡åŒæ—¶æ»¡è¶³è¿™ä¸¤ä¸ªæ–¹ç¨‹ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre><strong>è¾“å…¥ï¼š</strong>[&quot;b==a&quot;,&quot;a==b&quot;]
<strong>è¾“å‡ºï¼š</strong>true
<strong>è§£é‡Šï¼š</strong>æˆ‘ä»¬å¯ä»¥æŒ‡å®š a = 1 ä¸” b = 1 ä»¥æ»¡è¶³æ»¡è¶³è¿™ä¸¤ä¸ªæ–¹ç¨‹ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre><strong>è¾“å…¥ï¼š</strong>[&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]
<strong>è¾“å‡ºï¼š</strong>true
</pre>

<p><strong>ç¤ºä¾‹ 4ï¼š</strong></p>

<pre><strong>è¾“å…¥ï¼š</strong>[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]
<strong>è¾“å‡ºï¼š</strong>false
</pre>

<p><strong>ç¤ºä¾‹ 5ï¼š</strong></p>

<pre><strong>è¾“å…¥ï¼š</strong>[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]
<strong>è¾“å‡ºï¼š</strong>true
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ol>
	<li><code>1 &lt;= equations.length &lt;= 500</code></li>
	<li><code>equations[i].length == 4</code></li>
	<li><code>equations[i][0]</code> å’Œ&nbsp;<code>equations[i][3]</code>&nbsp;æ˜¯å°å†™å­—æ¯</li>
	<li><code>equations[i][1]</code> è¦ä¹ˆæ˜¯&nbsp;<code>&#39;=&#39;</code>ï¼Œè¦ä¹ˆæ˜¯&nbsp;<code>&#39;!&#39;</code></li>
	<li><code>equations[i][2]</code>&nbsp;æ˜¯&nbsp;<code>&#39;=&#39;</code></li>
</ol>
</div>

## é€šè¿‡ä»£ç 
<RecoDemo>
</RecoDemo>


## é«˜èµé¢˜è§£
### ğŸ“º è§†é¢‘é¢˜è§£  
![990. ç­‰å¼æ–¹ç¨‹çš„å¯æ»¡è¶³æ€§.mp4](fa3c8d24-ca62-4a44-bff8-bae421e2838c)

### ğŸ“– æ–‡å­—é¢˜è§£
#### æ–¹æ³•ä¸€ï¼šå¹¶æŸ¥é›†

æˆ‘ä»¬å¯ä»¥å°†æ¯ä¸€ä¸ªå˜é‡çœ‹ä½œå›¾ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼ŒæŠŠç›¸ç­‰çš„å…³ç³» `==` çœ‹ä½œæ˜¯è¿æ¥ä¸¤ä¸ªèŠ‚ç‚¹çš„è¾¹ï¼Œé‚£ä¹ˆç”±äºè¡¨ç¤ºç›¸ç­‰å…³ç³»çš„ç­‰å¼æ–¹ç¨‹å…·æœ‰ä¼ é€’æ€§ï¼Œå³å¦‚æœ `a==b` å’Œ `b==c` æˆç«‹ï¼Œåˆ™ `a==c` ä¹Ÿæˆç«‹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ‰€æœ‰ç›¸ç­‰çš„å˜é‡å±äºåŒä¸€ä¸ªè¿é€šåˆ†é‡ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¹¶æŸ¥é›†æ¥ç»´æŠ¤è¿™ç§è¿é€šåˆ†é‡çš„å…³ç³»ã€‚

é¦–å…ˆéå†æ‰€æœ‰çš„ç­‰å¼ï¼Œæ„é€ å¹¶æŸ¥é›†ã€‚åŒä¸€ä¸ªç­‰å¼ä¸­çš„ä¸¤ä¸ªå˜é‡å±äºåŒä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œå› æ­¤å°†ä¸¤ä¸ªå˜é‡è¿›è¡Œåˆå¹¶ã€‚

ç„¶åéå†æ‰€æœ‰çš„ä¸ç­‰å¼ã€‚åŒä¸€ä¸ªä¸ç­‰å¼ä¸­çš„ä¸¤ä¸ªå˜é‡ä¸èƒ½å±äºåŒä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œå› æ­¤å¯¹ä¸¤ä¸ªå˜é‡åˆ†åˆ«æŸ¥æ‰¾å…¶æ‰€åœ¨çš„è¿é€šåˆ†é‡ï¼Œå¦‚æœä¸¤ä¸ªå˜é‡åœ¨åŒä¸€ä¸ªè¿é€šåˆ†é‡ä¸­ï¼Œåˆ™äº§ç”ŸçŸ›ç›¾ï¼Œè¿”å› `false`ã€‚

å¦‚æœéå†å®Œæ‰€æœ‰çš„ä¸ç­‰å¼æ²¡æœ‰å‘ç°çŸ›ç›¾ï¼Œåˆ™è¿”å› `true`ã€‚

![fig1](https://assets.leetcode-cn.com/solution-static/990/990_fig1.gif){:width="90%"}

å…·ä½“å®ç°æ–¹é¢ï¼Œä½¿ç”¨ä¸€ä¸ªæ•°ç»„ `parent` å­˜å‚¨æ¯ä¸ªå˜é‡çš„è¿é€šåˆ†é‡ä¿¡æ¯ï¼Œå…¶ä¸­çš„æ¯ä¸ªå…ƒç´ è¡¨ç¤ºå½“å‰å˜é‡æ‰€åœ¨çš„è¿é€šåˆ†é‡çš„çˆ¶èŠ‚ç‚¹ä¿¡æ¯ï¼Œå¦‚æœçˆ¶èŠ‚ç‚¹æ˜¯è‡ªèº«ï¼Œè¯´æ˜è¯¥å˜é‡ä¸ºæ‰€åœ¨çš„è¿é€šåˆ†é‡çš„æ ¹èŠ‚ç‚¹ã€‚ä¸€å¼€å§‹æ‰€æœ‰å˜é‡çš„çˆ¶èŠ‚ç‚¹éƒ½æ˜¯å®ƒä»¬è‡ªèº«ã€‚å¯¹äºåˆå¹¶æ“ä½œï¼Œæˆ‘ä»¬å°†ç¬¬ä¸€ä¸ªå˜é‡çš„æ ¹èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æŒ‡å‘ç¬¬äºŒä¸ªå˜é‡çš„æ ¹èŠ‚ç‚¹ï¼›å¯¹äºæŸ¥æ‰¾æ“ä½œï¼Œæˆ‘ä»¬æ²¿ç€å½“å‰å˜é‡çš„çˆ¶èŠ‚ç‚¹ä¸€è·¯å‘ä¸ŠæŸ¥æ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°æ ¹èŠ‚ç‚¹ã€‚

```Java [sol1-Java]
class Solution {
    public boolean equationsPossible(String[] equations) {
        int[] parent = new int[26];
        for (int i = 0; i < 26; i++) {
            parent[i] = i;
        }
        for (String str : equations) {
            if (str.charAt(1) == '=') {
                int index1 = str.charAt(0) - 'a';
                int index2 = str.charAt(3) - 'a';
                union(parent, index1, index2);
            }
        }
        for (String str : equations) {
            if (str.charAt(1) == '!') {
                int index1 = str.charAt(0) - 'a';
                int index2 = str.charAt(3) - 'a';
                if (find(parent, index1) == find(parent, index2)) {
                    return false;
                }
            }
        }
        return true;
    }

    public void union(int[] parent, int index1, int index2) {
        parent[find(parent, index1)] = find(parent, index2);
    }

    public int find(int[] parent, int index) {
        while (parent[index] != index) {
            parent[index] = parent[parent[index]];
            index = parent[index];
        }
        return index;
    }
}
```

```C++ [sol1-C++]
class UnionFind {
private:
    vector<int> parent;

public:
    UnionFind() {
        parent.resize(26);
        iota(parent.begin(), parent.end(), 0);
    }

    int find(int index) {
        if (index == parent[index]) {
            return index;
        }
        parent[index] = find(parent[index]);
        return parent[index];
    }

    void unite(int index1, int index2) {
        parent[find(index1)] = find(index2);
    }
};

class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
        UnionFind uf;
        for (const string& str: equations) {
            if (str[1] == '=') {
                int index1 = str[0] - 'a';
                int index2 = str[3] - 'a';
                uf.unite(index1, index2);
            }
        }
        for (const string& str: equations) {
            if (str[1] == '!') {
                int index1 = str[0] - 'a';
                int index2 = str[3] - 'a';
                if (uf.find(index1) == uf.find(index2)) {
                    return false;
                }
            }
        }
        return true;
    }
};
```

```Python [sol1-Python3]
class Solution:

    class UnionFind:
        def __init__(self):
            self.parent = list(range(26))
        
        def find(self, index):
            if index == self.parent[index]:
                return index
            self.parent[index] = self.find(self.parent[index])
            return self.parent[index]
        
        def union(self, index1, index2):
            self.parent[self.find(index1)] = self.find(index2)


    def equationsPossible(self, equations: List[str]) -> bool:
        uf = Solution.UnionFind()
        for st in equations:
            if st[1] == "=":
                index1 = ord(st[0]) - ord("a")
                index2 = ord(st[3]) - ord("a")
                uf.union(index1, index2)
        for st in equations:
            if st[1] == "!":
                index1 = ord(st[0]) - ord("a")
                index2 = ord(st[3]) - ord("a")
                if uf.find(index1) == uf.find(index2):
                    return False
        return True
```

```golang [sol1-Golang]
func equationsPossible(equations []string) bool {
    parent := make([]int, 26)
    for i := 0; i < 26; i++ {
        parent[i] = i
    }
    for _, str := range equations {
        if str[1] == '=' {
            index1 := int(str[0] - 'a')
            index2 := int(str[3] - 'a')
            union(parent, index1, index2)
        }
    }

    for _, str := range equations {
        if str[1] == '!' {
            index1 := int(str[0] - 'a')
            index2 := int(str[3] - 'a')
            if find(parent, index1) == find(parent, index2) {
                return false
            }
        }
    }
    return true
}

func union(parent []int, index1, index2 int) {
    parent[find(parent, index1)] = find(parent, index2)
}

func find(parent []int, index int) int {
    for parent[index] != index {
        parent[index] = parent[parent[index]]
        index = parent[index]
    }
    return index
}
```

**å¤æ‚åº¦åˆ†æ**

* æ—¶é—´å¤æ‚åº¦ï¼š$O(n+C \log C)$ï¼Œå…¶ä¸­ $n$ æ˜¯ `equations` ä¸­çš„æ–¹ç¨‹æ•°é‡ï¼Œ$C$ æ˜¯å˜é‡çš„æ€»æ•°ï¼Œåœ¨æœ¬é¢˜ä¸­å˜é‡éƒ½æ˜¯å°å†™å­—æ¯ï¼Œå³ $C \leq 26$ã€‚ä¸Šé¢çš„å¹¶æŸ¥é›†ä»£ç ä¸­ä½¿ç”¨äº†è·¯å¾„å‹ç¼©ä¼˜åŒ–ï¼Œå¯¹äºæ¯ä¸ªæ–¹ç¨‹çš„åˆå¹¶å’ŒæŸ¥æ‰¾çš„å‡æ‘Šæ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ $O(\log C)$ã€‚ç”±äºéœ€è¦éå†æ¯ä¸ªæ–¹ç¨‹ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n+C \log C)$ã€‚

* ç©ºé—´å¤æ‚åº¦ï¼š$O(C)$ã€‚åˆ›å»ºä¸€ä¸ªæ•°ç»„ `parent` å­˜å‚¨æ¯ä¸ªå˜é‡çš„è¿é€šåˆ†é‡ä¿¡æ¯ï¼Œç”±äºå˜é‡éƒ½æ˜¯å°å†™å­—æ¯ï¼Œå› æ­¤ `parent` æ˜¯é•¿åº¦ä¸º $C$ã€‚

## ç»Ÿè®¡ä¿¡æ¯
| é€šè¿‡æ¬¡æ•° | æäº¤æ¬¡æ•° | ACæ¯”ç‡ |
| :------: | :------: | :------: |
|    34945    |    68906    |   50.7%   |

## æäº¤å†å²
| æäº¤æ—¶é—´ | æäº¤ç»“æœ | æ‰§è¡Œæ—¶é—´ |  å†…å­˜æ¶ˆè€—  | è¯­è¨€ |
| :------: | :------: | :------: | :--------: | :--------: |
