---
title: é¢è¯•é¢˜ 03.04-åŒ–æ ˆä¸ºé˜Ÿ(Implement Queue using Stacks LCCI)
categories:
  - ç®€å•
tags:
  - æ ˆ
  - è®¾è®¡
  - é˜Ÿåˆ—
abbrlink: 1419918903
date: 2021-12-03 21:45:35
---

> åŸæ–‡é“¾æ¥: https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci


## è‹±æ–‡åŸæ–‡
<div><p>Implement a MyQueue class which implements a queue using two stacks.</p>
&nbsp;

<p><strong>Example: </strong></p>

<pre>
MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);
queue.peek();  // return 1
queue.pop();   // return 1
queue.empty(); // return false</pre>

<p>&nbsp;</p>

<p><b>Notes:</b></p>

<ul>
	<li>You must use&nbsp;<i>only</i>&nbsp;standard operations of a stack -- which means only&nbsp;<code>push to top</code>,&nbsp;<code>peek/pop from top</code>,&nbsp;<code>size</code>, and&nbsp;<code>is empty</code>&nbsp;operations are valid.</li>
	<li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>
	<li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>
</ul>

<p>&nbsp;</p>
</div>

## ä¸­æ–‡é¢˜ç›®
<div><p>å®ç°ä¸€ä¸ªMyQueueç±»ï¼Œè¯¥ç±»ç”¨ä¸¤ä¸ªæ ˆæ¥å®ç°ä¸€ä¸ªé˜Ÿåˆ—ã€‚</p><br><p><strong>ç¤ºä¾‹ï¼š</strong><pre>MyQueue queue = new MyQueue();<br><br>queue.push(1);<br>queue.push(2);<br>queue.peek();  // è¿”å› 1<br>queue.pop();   // è¿”å› 1<br>queue.empty(); // è¿”å› false</pre></p><br><p><strong>è¯´æ˜ï¼š</strong><br><ul><li>ä½ åªèƒ½ä½¿ç”¨æ ‡å‡†çš„æ ˆæ“ä½œ -- ä¹Ÿå°±æ˜¯åªæœ‰ <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code> å’Œ <code>is empty</code> æ“ä½œæ˜¯åˆæ³•çš„ã€‚</li><li>ä½ æ‰€ä½¿ç”¨çš„è¯­è¨€ä¹Ÿè®¸ä¸æ”¯æŒæ ˆã€‚ä½ å¯ä»¥ä½¿ç”¨ list æˆ–è€… dequeï¼ˆåŒç«¯é˜Ÿåˆ—ï¼‰æ¥æ¨¡æ‹Ÿä¸€ä¸ªæ ˆï¼Œåªè¦æ˜¯æ ‡å‡†çš„æ ˆæ“ä½œå³å¯ã€‚</li><li>å‡è®¾æ‰€æœ‰æ“ä½œéƒ½æ˜¯æœ‰æ•ˆçš„ ï¼ˆä¾‹å¦‚ï¼Œä¸€ä¸ªç©ºçš„é˜Ÿåˆ—ä¸ä¼šè°ƒç”¨ pop æˆ–è€… peek æ“ä½œï¼‰ã€‚</li></ul></p></div>

## é€šè¿‡ä»£ç 
<RecoDemo>
</RecoDemo>


## é«˜èµé¢˜è§£
![å›¾è§£æ¯æ—¥ä¸€ç»ƒ.jpg](../images/implement-queue-using-stacks-lcci-0.jpg)

---

### ğŸ§  è§£é¢˜æ€è·¯

é˜Ÿåˆ—çš„ç‰¹æ€§æ˜¯ $FIFO$ï¼ˆå…ˆå…¥å…ˆå‡ºï¼‰ï¼Œè€Œæ ˆçš„ç‰¹æ€§æ˜¯ $FILO$ï¼ˆå…ˆå…¥åå‡ºï¼‰ã€‚

çŸ¥é“ä¸¤è€…ç‰¹æ€§ä¹‹åï¼Œæˆ‘ä»¬éœ€è¦ç”¨ä¸¤ä¸ªæ ˆæ¥æ¨¡æ‹Ÿé˜Ÿåˆ—çš„ç‰¹æ€§ï¼Œä¸€ä¸ªæ ˆä¸ºå…¥é˜Ÿæ ˆï¼Œä¸€ä¸ªæ ˆä¸ºå‡ºå¯¹æ ˆã€‚

å½“å‡ºé˜Ÿæ ˆå­˜åœ¨å†…å®¹æ—¶ï¼Œå‡ºé˜Ÿæ ˆçš„æ ˆé¡¶ï¼Œå³ä¸ºç¬¬ä¸€ä¸ªå‡ºé˜Ÿçš„å…ƒç´ ã€‚

è‹¥å‡ºé˜Ÿæ ˆæ— å…ƒç´ ï¼Œæˆ‘ä»¬çš„éœ€æ±‚åˆæ˜¯å‡ºé˜Ÿçš„è¯ï¼Œæˆ‘ä»¬å°±éœ€è¦å°†å…¥é˜Ÿæ ˆçš„å†…å®¹ååºå¯¼å…¥å‡ºé˜Ÿæ ˆï¼Œç„¶åå¼¹å‡ºæ ˆé¡¶å³å¯ã€‚

æ³¨æ„ï¼šæ ¹æ®æ ˆçš„çš„ç‰¹æ€§ï¼Œæˆ‘ä»¬ä»…èƒ½ä½¿ç”¨ $push$ å’Œ $pop$ æ“ä½œã€‚

---

### ğŸ¨ å›¾è§£æ¼”ç¤º

<![1.jpg](../images/implement-queue-using-stacks-lcci-1.jpg),![2.jpg](../images/implement-queue-using-stacks-lcci-2.jpg),![3.jpg](../images/implement-queue-using-stacks-lcci-3.jpg),![4.jpg](../images/implement-queue-using-stacks-lcci-4.jpg),![5.jpg](../images/implement-queue-using-stacks-lcci-5.jpg),![6.jpg](../images/implement-queue-using-stacks-lcci-6.jpg),![7.jpg](../images/implement-queue-using-stacks-lcci-7.jpg),![8.jpg](../images/implement-queue-using-stacks-lcci-8.jpg),![9.jpg](../images/implement-queue-using-stacks-lcci-9.jpg),![10.jpg](../images/implement-queue-using-stacks-lcci-10.jpg)>

---

### ä»£ç 

```Javascript []
var MyQueue = function() {
    this.stackIn = [];
    this.stackOut = [];
};

MyQueue.prototype.push = function(x) {
    this.stackIn.push(x);
};

MyQueue.prototype.pop = function() {
    while(this.stackIn.length > 1){
        this.stackOut.push(this.stackIn.pop());
    }
    let ans =  this.stackIn.pop();
    while(this.stackOut.length){
        this.stackIn.push(this.stackOut.pop());
    }
    return ans;
};

MyQueue.prototype.peek = function() {
    while(this.stackIn.length){
        this.stackOut.push(this.stackIn.pop());
    }
    let ans =  this.stackOut[this.stackOut.length - 1];
    while(this.stackOut.length){
        this.stackIn.push(this.stackOut.pop());
    }
    return ans;
};

MyQueue.prototype.empty = function() {
    return !this.stackIn.length && !this.stackOut.length;
};
```
```C++ []
class MyQueue {
private:
    stack<int> inStack, outStack;

    void in2out() {
        while (!inStack.empty()) {
            outStack.push(inStack.top());
            inStack.pop();
        }
    }

public:
    MyQueue() {}

    void push(int x) {
        inStack.push(x);
    }

    int pop() {
        if (outStack.empty()) {
            in2out();
        }
        int x = outStack.top();
        outStack.pop();
        return x;
    }

    int peek() {
        if (outStack.empty()) {
            in2out();
        }
        return outStack.top();
    }

    bool empty() {
        return inStack.empty() && outStack.empty();
    }
};
```
```Java []
class MyQueue {
    Deque<Integer> inStack;
    Deque<Integer> outStack;

    public MyQueue() {
        inStack = new LinkedList<Integer>();
        outStack = new LinkedList<Integer>();
    }
    
    public void push(int x) {
        inStack.push(x);
    }
    
    public int pop() {
        if (outStack.isEmpty()) {
            in2out();
        }
        return outStack.pop();
    }
    
    public int peek() {
        if (outStack.isEmpty()) {
            in2out();
        }
        return outStack.peek();
    }
    
    public boolean empty() {
        return inStack.isEmpty() && outStack.isEmpty();
    }

    private void in2out() {
        while (!inStack.isEmpty()) {
            outStack.push(inStack.pop());
        }
    }
}
```
```Golang []
type MyQueue struct {
    inStack, outStack []int
}

func Constructor() MyQueue {
    return MyQueue{}
}

func (q *MyQueue) Push(x int) {
    q.inStack = append(q.inStack, x)
}

func (q *MyQueue) in2out() {
    for len(q.inStack) > 0 {
        q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])
        q.inStack = q.inStack[:len(q.inStack)-1]
    }
}

func (q *MyQueue) Pop() int {
    if len(q.outStack) == 0 {
        q.in2out()
    }
    x := q.outStack[len(q.outStack)-1]
    q.outStack = q.outStack[:len(q.outStack)-1]
    return x
}

func (q *MyQueue) Peek() int {
    if len(q.outStack) == 0 {
        q.in2out()
    }
    return q.outStack[len(q.outStack)-1]
}

func (q *MyQueue) Empty() bool {
    return len(q.inStack) == 0 && len(q.outStack) == 0
}
```
```C []
typedef struct {
    int* stk;
    int stkSize;
    int stkCapacity;
} Stack;

Stack* stackCreate(int cpacity) {
    Stack* ret = malloc(sizeof(Stack));
    ret->stk = malloc(sizeof(int) * cpacity);
    ret->stkSize = 0;
    ret->stkCapacity = cpacity;
    return ret;
}

void stackPush(Stack* obj, int x) {
    obj->stk[obj->stkSize++] = x;
}

void stackPop(Stack* obj) {
    obj->stkSize--;
}

int stackTop(Stack* obj) {
    return obj->stk[obj->stkSize - 1];
}

bool stackEmpty(Stack* obj) {
    return obj->stkSize == 0;
}

void stackFree(Stack* obj) {
    free(obj->stk);
}

typedef struct {
    Stack* inStack;
    Stack* outStack;
} MyQueue;

MyQueue* myQueueCreate() {
    MyQueue* ret = malloc(sizeof(MyQueue));
    ret->inStack = stackCreate(100);
    ret->outStack = stackCreate(100);
    return ret;
}

void in2out(MyQueue* obj) {
    while (!stackEmpty(obj->inStack)) {
        stackPush(obj->outStack, stackTop(obj->inStack));
        stackPop(obj->inStack);
    }
}

void myQueuePush(MyQueue* obj, int x) {
    stackPush(obj->inStack, x);
}

int myQueuePop(MyQueue* obj) {
    if (stackEmpty(obj->outStack)) {
        in2out(obj);
    }
    int x = stackTop(obj->outStack);
    stackPop(obj->outStack);
    return x;
}

int myQueuePeek(MyQueue* obj) {
    if (stackEmpty(obj->outStack)) {
        in2out(obj);
    }
    return stackTop(obj->outStack);
}

bool myQueueEmpty(MyQueue* obj) {
    return stackEmpty(obj->inStack) && stackEmpty(obj->outStack);
}

void myQueueFree(MyQueue* obj) {
    stackFree(obj->inStack);
    stackFree(obj->outStack);
}
```

---

### è½¬èº«æŒ¥æ‰‹

å˜¿ï¼Œå°‘å¹´ï¼Œåšå›¾ä¸æ˜“ï¼Œç•™ä¸‹ä¸ªèµæˆ–è¯„è®ºå†èµ°å§ï¼è°¢å•¦~ ğŸ’

å·®ç‚¹å¿˜äº†ï¼Œç¥ä½ ç‰›å¹´å¤§å‰ ğŸ® ï¼ŒAC å’Œ Offer ğŸ“‘ å¤šå¤šç›Šå–„~

â›²â›²â›² æœŸå¾…ä¸‹æ¬¡å†è§~ 

## ç»Ÿè®¡ä¿¡æ¯
| é€šè¿‡æ¬¡æ•° | æäº¤æ¬¡æ•° | ACæ¯”ç‡ |
| :------: | :------: | :------: |
|    24498    |    34322    |   71.4%   |

## æäº¤å†å²
| æäº¤æ—¶é—´ | æäº¤ç»“æœ | æ‰§è¡Œæ—¶é—´ |  å†…å­˜æ¶ˆè€—  | è¯­è¨€ |
| :------: | :------: | :------: | :--------: | :--------: |
