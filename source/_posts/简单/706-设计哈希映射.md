---
title: 706-è®¾è®¡å“ˆå¸Œæ˜ å°„(Design HashMap)
categories:
  - ç®€å•
tags:
  - è®¾è®¡
  - æ•°ç»„
  - å“ˆå¸Œè¡¨
  - é“¾è¡¨
  - å“ˆå¸Œå‡½æ•°
abbrlink: 2913618238
date: 2021-12-03 22:32:44
---

> åŸæ–‡é“¾æ¥: https://leetcode-cn.com/problems/design-hashmap


## è‹±æ–‡åŸæ–‡
<div><p>Design a HashMap without using any built-in hash table libraries.</p>

<p>Implement the <code>MyHashMap</code> class:</p>

<ul>
	<li><code>MyHashMap()</code> initializes the object with an empty map.</li>
	<li><code>void put(int key, int value)</code> inserts a <code>(key, value)</code> pair into the HashMap. If the <code>key</code> already exists in the map, update the corresponding <code>value</code>.</li>
	<li><code>int get(int key)</code> returns the <code>value</code> to which the specified <code>key</code> is mapped, or <code>-1</code> if this map contains no mapping for the <code>key</code>.</li>
	<li><code>void remove(key)</code> removes the <code>key</code> and its corresponding <code>value</code> if the map contains the mapping for the <code>key</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre>
<strong>Input</strong>
[&quot;MyHashMap&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;remove&quot;, &quot;get&quot;]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
<strong>Output</strong>
[null, null, null, 1, -1, null, 1, null, -1]

<strong>Explanation</strong>
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // The map is now [[1,1]]
myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]
myHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]
myHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]
myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)
myHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]
myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]
myHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= key, value &lt;= 10<sup>6</sup></code></li>
	<li>At most <code>10<sup>4</sup></code> calls will be made to <code>put</code>, <code>get</code>, and <code>remove</code>.</li>
</ul>
</div>

## ä¸­æ–‡é¢˜ç›®
<div><p>ä¸ä½¿ç”¨ä»»ä½•å†…å»ºçš„å“ˆå¸Œè¡¨åº“è®¾è®¡ä¸€ä¸ªå“ˆå¸Œæ˜ å°„ï¼ˆHashMapï¼‰ã€‚</p>

<p>å®ç° <code>MyHashMap</code> ç±»ï¼š</p>

<ul>
	<li><code>MyHashMap()</code> ç”¨ç©ºæ˜ å°„åˆå§‹åŒ–å¯¹è±¡</li>
	<li><code>void put(int key, int value)</code> å‘ HashMap æ’å…¥ä¸€ä¸ªé”®å€¼å¯¹ <code>(key, value)</code> ã€‚å¦‚æœ <code>key</code> å·²ç»å­˜åœ¨äºæ˜ å°„ä¸­ï¼Œåˆ™æ›´æ–°å…¶å¯¹åº”çš„å€¼ <code>value</code> ã€‚</li>
	<li><code>int get(int key)</code> è¿”å›ç‰¹å®šçš„ <code>key</code> æ‰€æ˜ å°„çš„ <code>value</code> ï¼›å¦‚æœæ˜ å°„ä¸­ä¸åŒ…å« <code>key</code> çš„æ˜ å°„ï¼Œè¿”å› <code>-1</code> ã€‚</li>
	<li><code>void remove(key)</code> å¦‚æœæ˜ å°„ä¸­å­˜åœ¨ <code>key</code> çš„æ˜ å°„ï¼Œåˆ™ç§»é™¤ <code>key</code> å’Œå®ƒæ‰€å¯¹åº”çš„ <code>value</code> ã€‚</li>
</ul>

<p>Â </p>

<p><strong>ç¤ºä¾‹ï¼š</strong></p>

<pre>
<strong>è¾“å…¥</strong>ï¼š
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
<strong>è¾“å‡º</strong>ï¼š
[null, null, null, 1, -1, null, 1, null, -1]

<strong>è§£é‡Š</strong>ï¼š
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // myHashMap ç°åœ¨ä¸º [[1,1]]
myHashMap.put(2, 2); // myHashMap ç°åœ¨ä¸º [[1,1], [2,2]]
myHashMap.get(1);    // è¿”å› 1 ï¼ŒmyHashMap ç°åœ¨ä¸º [[1,1], [2,2]]
myHashMap.get(3);    // è¿”å› -1ï¼ˆæœªæ‰¾åˆ°ï¼‰ï¼ŒmyHashMap ç°åœ¨ä¸º [[1,1], [2,2]]
myHashMap.put(2, 1); // myHashMap ç°åœ¨ä¸º [[1,1], [2,1]]ï¼ˆæ›´æ–°å·²æœ‰çš„å€¼ï¼‰
myHashMap.get(2);    // è¿”å› 1 ï¼ŒmyHashMap ç°åœ¨ä¸º [[1,1], [2,1]]
myHashMap.remove(2); // åˆ é™¤é”®ä¸º 2 çš„æ•°æ®ï¼ŒmyHashMap ç°åœ¨ä¸º [[1,1]]
myHashMap.get(2);    // è¿”å› -1ï¼ˆæœªæ‰¾åˆ°ï¼‰ï¼ŒmyHashMap ç°åœ¨ä¸º [[1,1]]
</pre>

<p>Â </p>

<p><strong>æç¤ºï¼š</strong></p>

<ul>
	<li><code>0 <= key, value <= 10<sup>6</sup></code></li>
	<li>æœ€å¤šè°ƒç”¨ <code>10<sup>4</sup></code> æ¬¡ <code>put</code>ã€<code>get</code> å’Œ <code>remove</code> æ–¹æ³•</li>
</ul>

<p>Â </p>

<p><strong>è¿›é˜¶ï¼š</strong>ä½ èƒ½å¦ä¸ä½¿ç”¨å†…ç½®çš„ HashMap åº“è§£å†³æ­¤é—®é¢˜ï¼Ÿ</p>
</div>

## é€šè¿‡ä»£ç 
<RecoDemo>
</RecoDemo>


## é«˜èµé¢˜è§£
![å›¾è§£æ¯æ—¥ä¸€ç»ƒ.jpg](../images/design-hashmap-0.jpg)

---

### ğŸ§  è§£é¢˜æ€è·¯

æœ¬é¢˜è€ƒæŸ¥æˆ‘ä»¬å¯¹äºå®ç°å“ˆå¸Œè¡¨ï¼Œæœ‰å“ªäº›æ–¹æ³•ï¼Œåˆ†åˆ«æœ‰ä»€ä¹ˆåˆ©å¼Šï¼Ÿ

å®ç°å“ˆå¸Œè¡¨çš„åŸç†ï¼Œå…¶å®æˆ‘ä»¬ä¼šé‡åˆ°ä¸€ä¸ªæŠ‰æ‹©ï¼Œé‚£å°±æ˜¯æ—¶é—´å’Œç©ºé—´çš„å–èˆã€‚

å®ç°æ–¹å¼æœ‰ä¸¤ç§ï¼š

1. è¶…å¤§æ•°ç»„ï¼šä¸è€ƒè™‘ç©ºé—´å¤æ‚åº¦ï¼Œåˆ›å»ºè¶…å¤§æ•°ç»„ï¼Œæ¯ä¸ªæ•°éƒ½èƒ½å•ç‹¬å­˜å…¥ï¼Œä¸”ä¸ä¼šä½ç½®å†²çªã€‚
2. é“¾åœ°å€æ³•ï¼šç©ºé—´/æ—¶é—´çš„æœ€ä½³å®è·µï¼ŒåŸºäºæ•°ç»„å®ç°ï¼Œå¹¶ä¸”é€šè¿‡ä¸€ä¸ª $hash$ å‡½æ•°ç”Ÿæˆä¸€ä¸ªå¯¹åº”çš„ç´¢å¼•ï¼Œå½“å¤šä¸ªæ•°ç´¢å¼•ä¸€è‡´çš„æ—¶å€™ï¼Œå†å¤„ç†å†²çªé—®é¢˜ï¼Œä¸€èˆ¬æˆ‘ä»¬ä½¿ç”¨é“¾åœ°å€æ³•è§£å†³å†²çªã€‚

---

### ğŸ¨ å›¾è§£æ¼”ç¤º

<![1.jpg](../images/design-hashmap-1.jpg),![2.jpg](../images/design-hashmap-2.jpg),![3.jpg](../images/design-hashmap-3.jpg)>

---

### ğŸ­ ç¤ºä¾‹ä»£ç 

```Javascript []
var MyHashMap = function() {
    this.base = 1000;
    this.data = new Array(this.base).fill(0).map(i => new Array());
};

MyHashMap.prototype.put = function(key, value) {
    let hash = key % this.base;
    for(let i of this.data[hash]){
        if(i[0] === key) return i[1] = value;
    }
    this.data[hash].push([key, value]);
};

MyHashMap.prototype.get = function(key) {
    let hash = key % this.base;
    for(let i of this.data[hash]){
        if(i[0] === key) return i[1];
    }
    return -1;
};

MyHashMap.prototype.remove = function(key) {
    let hash = key % this.base;
    for(let i of this.data[hash]){
        if(i[0] === key) {
            let index = this.data[hash].indexOf(i);
            this.data[hash].splice(index, 1);
        }
    }
};
```
```C++ []
class MyHashMap {
private:
    vector<list<pair<int, int>>> data;
    static const int base = 769;
    static int hash(int key) {
        return key % base;
    }
public:
    MyHashMap(): data(base) {}
    
    void put(int key, int value) {
        int h = hash(key);
        for (auto it = data[h].begin(); it != data[h].end(); it++) {
            if ((*it).first == key) {
                (*it).second = value;
                return;
            }
        }
        data[h].push_back(make_pair(key, value));
    }
    
    int get(int key) {
        int h = hash(key);
        for (auto it = data[h].begin(); it != data[h].end(); it++) {
            if ((*it).first == key) {
                return (*it).second;
            }
        }
        return -1;
    }
    
    void remove(int key) {
        int h = hash(key);
        for (auto it = data[h].begin(); it != data[h].end(); it++) {
            if ((*it).first == key) {
                data[h].erase(it);
                return;
            }
        }
    }
};
```
```Java []
class MyHashMap {
    private class Pair {
        private int key;
        private int value;

        public Pair(int key, int value) {
            this.key = key;
            this.value = value;
        }

        public int getKey() {
            return key;
        }

        public int getValue() {
            return value;
        }

        public void setValue(int value) {
            this.value = value;
        }
    }

    private static final int BASE = 769;
    private LinkedList[] data;

    public MyHashMap() {
        data = new LinkedList[BASE];
        for (int i = 0; i < BASE; ++i) {
            data[i] = new LinkedList<Pair>();
        }
    }
    
    public void put(int key, int value) {
        int h = hash(key);
        Iterator<Pair> iterator = data[h].iterator();
        while (iterator.hasNext()) {
            Pair pair = iterator.next();
            if (pair.getKey() == key) {
                pair.setValue(value);
                return;
            }
        }
        data[h].offerLast(new Pair(key, value));
    }
    
    public int get(int key) {
        int h = hash(key);
        Iterator<Pair> iterator = data[h].iterator();
        while (iterator.hasNext()) {
            Pair pair = iterator.next();
            if (pair.getKey() == key) {
                return pair.value;
            }
        }
        return -1;
    }
    
    public void remove(int key) {
        int h = hash(key);
        Iterator<Pair> iterator = data[h].iterator();
        while (iterator.hasNext()) {
            Pair pair = iterator.next();
            if (pair.key == key) {
                data[h].remove(pair);
                return;
            }
        }
    }

    private static int hash(int key) {
        return key % BASE;
    }
}
```
```Golang []
const base = 769

type entry struct {
    key, value int
}

type MyHashMap struct {
    data []list.List
}

func Constructor() MyHashMap {
    return MyHashMap{make([]list.List, base)}
}

func (m *MyHashMap) hash(key int) int {
    return key % base
}

func (m *MyHashMap) Put(key, value int) {
    h := m.hash(key)
    for e := m.data[h].Front(); e != nil; e = e.Next() {
        if et := e.Value.(entry); et.key == key {
            e.Value = entry{key, value}
            return
        }
    }
    m.data[h].PushBack(entry{key, value})
}

func (m *MyHashMap) Get(key int) int {
    h := m.hash(key)
    for e := m.data[h].Front(); e != nil; e = e.Next() {
        if et := e.Value.(entry); et.key == key {
            return et.value
        }
    }
    return -1
}

func (m *MyHashMap) Remove(key int) {
    h := m.hash(key)
    for e := m.data[h].Front(); e != nil; e = e.Next() {
        if e.Value.(entry).key == key {
            m.data[h].Remove(e)
        }
    }
}
```
```C []
struct List {
    int key;
    int val;
    struct List* next;
};

void listPush(struct List* head, int key, int val) {
    struct List* tmp = malloc(sizeof(struct List));
    tmp->key = key;
    tmp->val = val;
    tmp->next = head->next;
    head->next = tmp;
}

void listDelete(struct List* head, int key) {
    for (struct List* it = head; it->next; it = it->next) {
        if (it->next->key == key) {
            struct List* tmp = it->next;
            it->next = tmp->next;
            free(tmp);
            break;
        }
    }
}

struct List* listFind(struct List* head, int key) {
    for (struct List* it = head; it->next; it = it->next) {
        if (it->next->key == key) {
            return it->next;
        }
    }
    return NULL;
}

void listFree(struct List* head) {
    while (head->next) {
        struct List* tmp = head->next;
        head->next = tmp->next;
        free(tmp);
    }
}

const int base = 769;

int hash(int key) {
    return key % base;
}

typedef struct {
    struct List* data;
} MyHashMap;

MyHashMap* myHashMapCreate() {
    MyHashMap* ret = malloc(sizeof(MyHashMap));
    ret->data = malloc(sizeof(struct List) * base);
    for (int i = 0; i < base; i++) {
        ret->data[i].key = 0;
        ret->data[i].val = 0;
        ret->data[i].next = NULL;
    }
    return ret;
}

void myHashMapPut(MyHashMap* obj, int key, int value) {
    int h = hash(key);
    struct List* rec = listFind(&(obj->data[h]), key);
    if (rec == NULL) {
        listPush(&(obj->data[h]), key, value);
    } else {
        rec->val = value;
    }
}

int myHashMapGet(MyHashMap* obj, int key) {
    int h = hash(key);
    struct List* rec = listFind(&(obj->data[h]), key);
    if (rec == NULL) {
        return -1;
    } else {
        return rec->val;
    }
}

void myHashMapRemove(MyHashMap* obj, int key) {
    int h = hash(key);
    listDelete(&(obj->data[h]), key);
}

void myHashMapFree(MyHashMap* obj) {
    for (int i = 0; i < base; i++) {
        listFree(&(obj->data[i]));
    }
    free(obj->data);
}
```

---

### è½¬èº«æŒ¥æ‰‹

å˜¿ï¼Œå°‘å¹´ï¼Œåšå›¾ä¸æ˜“ï¼Œç•™ä¸‹ä¸ªèµæˆ–è¯„è®ºå†èµ°å§ï¼è°¢å•¦~ ğŸ’

å·®ç‚¹å¿˜äº†ï¼Œç¥ä½ ç‰›å¹´å¤§å‰ ğŸ® ï¼ŒAC å’Œ Offer ğŸ“‘ å¤šå¤šç›Šå–„~

â›²â›²â›² æœŸå¾…ä¸‹æ¬¡å†è§~ 

## ç»Ÿè®¡ä¿¡æ¯
| é€šè¿‡æ¬¡æ•° | æäº¤æ¬¡æ•° | ACæ¯”ç‡ |
| :------: | :------: | :------: |
|    62371    |    97002    |   64.3%   |

## æäº¤å†å²
| æäº¤æ—¶é—´ | æäº¤ç»“æœ | æ‰§è¡Œæ—¶é—´ |  å†…å­˜æ¶ˆè€—  | è¯­è¨€ |
| :------: | :------: | :------: | :--------: | :--------: |


## ç›¸ä¼¼é¢˜ç›®
|                             é¢˜ç›®                             | éš¾åº¦ |
| :----------------------------------------------------------: | :---------: |
| [è®¾è®¡å“ˆå¸Œé›†åˆ](https://leetcode-cn.com/problems/design-hashset/) | ç®€å•|
